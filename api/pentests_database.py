"""Persistence for pentests: campaigns and findings.

Supports SQLite (local dev) and PostgreSQL (Cloud Run) via api.db layer.
"""

from __future__ import annotations

import json
import uuid
from datetime import datetime, timezone

from api.db import get_conn, adapt_sql, placeholder

# ── Severity ordering (lower = more severe) ─────────────────────────

_SEVERITY_ORDER = {"critical": 0, "high": 1, "medium": 2, "low": 3}

# ── Schema initialisation ───────────────────────────────────────────

_CREATE_PENTESTS = """
CREATE TABLE IF NOT EXISTS pentests (
    id TEXT PRIMARY KEY,
    user_email TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT DEFAULT '',
    vendor TEXT DEFAULT 'manual',
    vendor_id TEXT DEFAULT '',
    status TEXT DEFAULT 'planned',
    severity TEXT DEFAULT 'medium',
    start_date TEXT,
    end_date TEXT,
    scope TEXT DEFAULT '',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
)
"""

_CREATE_PENTEST_FINDINGS = """
CREATE TABLE IF NOT EXISTS pentest_findings (
    id TEXT PRIMARY KEY,
    pentest_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT DEFAULT '',
    severity TEXT DEFAULT 'medium',
    cvss_score REAL,
    status TEXT DEFAULT 'open',
    category TEXT DEFAULT '',
    affected_url TEXT DEFAULT '',
    remediation_notes TEXT DEFAULT '',
    evidence TEXT DEFAULT '',
    discovered_at TEXT NOT NULL,
    resolved_at TEXT,
    FOREIGN KEY (pentest_id) REFERENCES pentests(id)
)
"""


def init_pentest_tables() -> None:
    """Create pentest tables if they don't exist."""
    conn = get_conn()
    try:
        conn.execute(_CREATE_PENTESTS)
        conn.execute(_CREATE_PENTEST_FINDINGS)
        conn.commit()
    finally:
        conn.close()


# ── Pentests CRUD ────────────────────────────────────────────────────


def create_pentest(
    user_email: str,
    name: str,
    description: str = "",
    vendor: str = "manual",
    vendor_id: str = "",
    status: str = "planned",
    severity: str = "medium",
    start_date: str | None = None,
    end_date: str | None = None,
    scope: str = "",
) -> str:
    """Create a pentest and return its ID."""
    pentest_id = str(uuid.uuid4())
    now = datetime.now(timezone.utc).isoformat()
    p = placeholder
    conn = get_conn()
    try:
        conn.execute(
            f"""INSERT INTO pentests
               (id, user_email, name, description, vendor, vendor_id,
                status, severity, start_date, end_date, scope,
                created_at, updated_at)
               VALUES ({p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p})""",
            (
                pentest_id,
                user_email,
                name,
                description,
                vendor,
                vendor_id,
                status,
                severity,
                start_date,
                end_date,
                scope,
                now,
                now,
            ),
        )
        conn.commit()
        return pentest_id
    finally:
        conn.close()


def list_pentests(user_email: str) -> list[dict]:
    """List all pentests for a user, newest first."""
    conn = get_conn()
    try:
        rows = conn.execute(
            adapt_sql("SELECT * FROM pentests WHERE user_email = ? ORDER BY created_at DESC"),
            (user_email,),
        ).fetchall()
        return [dict(row) for row in rows]
    finally:
        conn.close()


def get_pentest(pentest_id: str) -> dict | None:
    """Get a pentest by ID, or None."""
    conn = get_conn()
    try:
        row = conn.execute(
            adapt_sql("SELECT * FROM pentests WHERE id = ?"), (pentest_id,)
        ).fetchone()
        return dict(row) if row else None
    finally:
        conn.close()


_ALLOWED_PENTEST_FIELDS = {
    "name",
    "description",
    "vendor",
    "vendor_id",
    "status",
    "severity",
    "start_date",
    "end_date",
    "scope",
}


def update_pentest(pentest_id: str, **fields) -> None:
    """Update allowed fields on a pentest."""
    updates = {k: v for k, v in fields.items() if k in _ALLOWED_PENTEST_FIELDS}
    if not updates:
        return
    updates["updated_at"] = datetime.now(timezone.utc).isoformat()
    p = placeholder
    set_clause = ", ".join(f"{k} = {p}" for k in updates)
    values = list(updates.values()) + [pentest_id]
    conn = get_conn()
    try:
        conn.execute(
            f"UPDATE pentests SET {set_clause} WHERE id = {p}",
            values,
        )
        conn.commit()
    finally:
        conn.close()


def delete_pentest(pentest_id: str) -> None:
    """Delete a pentest and cascade-delete its findings."""
    conn = get_conn()
    try:
        conn.execute(adapt_sql("DELETE FROM pentest_findings WHERE pentest_id = ?"), (pentest_id,))
        conn.execute(adapt_sql("DELETE FROM pentests WHERE id = ?"), (pentest_id,))
        conn.commit()
    finally:
        conn.close()


# ── Findings CRUD ────────────────────────────────────────────────────


def create_finding(
    pentest_id: str,
    title: str,
    description: str = "",
    severity: str = "medium",
    cvss_score: float | None = None,
    status: str = "open",
    category: str = "",
    affected_url: str = "",
    remediation_notes: str = "",
    evidence: str = "",
    discovered_at: str | None = None,
) -> str:
    """Create a finding and return its ID."""
    finding_id = str(uuid.uuid4())
    now = datetime.now(timezone.utc).isoformat()
    p = placeholder
    conn = get_conn()
    try:
        conn.execute(
            f"""INSERT INTO pentest_findings
               (id, pentest_id, title, description, severity, cvss_score,
                status, category, affected_url, remediation_notes, evidence,
                discovered_at, resolved_at)
               VALUES ({p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p})""",
            (
                finding_id,
                pentest_id,
                title,
                description,
                severity,
                cvss_score,
                status,
                category,
                affected_url,
                remediation_notes,
                evidence,
                discovered_at or now,
                None,
            ),
        )
        conn.commit()
        return finding_id
    finally:
        conn.close()


def list_findings(
    pentest_id: str, status: str = "", severity: str = ""
) -> list[dict]:
    """List findings for a pentest, sorted by severity then discovered_at."""
    p = placeholder
    conn = get_conn()
    try:
        query = f"SELECT * FROM pentest_findings WHERE pentest_id = {p}"
        params: list = [pentest_id]
        if status:
            query += f" AND status = {p}"
            params.append(status)
        if severity:
            query += f" AND severity = {p}"
            params.append(severity)
        rows = conn.execute(query, params).fetchall()
        results = [dict(row) for row in rows]
        results.sort(
            key=lambda r: (
                _SEVERITY_ORDER.get(r["severity"], 99),
                r["discovered_at"],
            )
        )
        return results
    finally:
        conn.close()


def get_finding(finding_id: str) -> dict | None:
    """Get a single finding by ID."""
    conn = get_conn()
    try:
        row = conn.execute(
            adapt_sql("SELECT * FROM pentest_findings WHERE id = ?"), (finding_id,)
        ).fetchone()
        return dict(row) if row else None
    finally:
        conn.close()


_ALLOWED_FINDING_FIELDS = {
    "title",
    "description",
    "severity",
    "cvss_score",
    "status",
    "category",
    "affected_url",
    "remediation_notes",
    "evidence",
    "resolved_at",
}


def update_finding(finding_id: str, **fields) -> None:
    """Update allowed fields on a finding."""
    updates = {k: v for k, v in fields.items() if k in _ALLOWED_FINDING_FIELDS}
    if not updates:
        return
    # Auto-set resolved_at when status changes to resolved
    if updates.get("status") == "resolved" and "resolved_at" not in updates:
        updates["resolved_at"] = datetime.now(timezone.utc).isoformat()
    p = placeholder
    set_clause = ", ".join(f"{k} = {p}" for k in updates)
    values = list(updates.values()) + [finding_id]
    conn = get_conn()
    try:
        conn.execute(
            f"UPDATE pentest_findings SET {set_clause} WHERE id = {p}",
            values,
        )
        conn.commit()
    finally:
        conn.close()


def get_finding_counts(pentest_id: str) -> dict:
    """Count findings by severity for a pentest."""
    conn = get_conn()
    try:
        rows = conn.execute(
            adapt_sql(
                """SELECT severity, COUNT(*) as cnt
                   FROM pentest_findings
                   WHERE pentest_id = ?
                   GROUP BY severity"""
            ),
            (pentest_id,),
        ).fetchall()
        counts = {r["severity"]: r["cnt"] for r in rows}
        return {
            "critical": counts.get("critical", 0),
            "high": counts.get("high", 0),
            "medium": counts.get("medium", 0),
            "low": counts.get("low", 0),
            "total": sum(counts.values()),
        }
    finally:
        conn.close()


def bulk_import_findings(pentest_id: str, findings: list[dict]) -> int:
    """Bulk import findings for a pentest. Returns the number inserted."""
    now = datetime.now(timezone.utc).isoformat()
    p = placeholder
    conn = get_conn()
    try:
        count = 0
        for f in findings:
            conn.execute(
                f"""INSERT INTO pentest_findings
                   (id, pentest_id, title, description, severity, cvss_score,
                    status, category, affected_url, remediation_notes, evidence,
                    discovered_at, resolved_at)
                   VALUES ({p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p}, {p})""",
                (
                    str(uuid.uuid4()),
                    pentest_id,
                    f.get("title", ""),
                    f.get("description", ""),
                    f.get("severity", "medium"),
                    f.get("cvss_score"),
                    f.get("status", "open"),
                    f.get("category", ""),
                    f.get("affected_url", ""),
                    f.get("remediation_notes", ""),
                    f.get("evidence", ""),
                    f.get("discovered_at", now),
                    f.get("resolved_at"),
                ),
            )
            count += 1
        conn.commit()
        return count
    finally:
        conn.close()
